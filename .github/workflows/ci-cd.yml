name: codiit-backend-ci-cd

on:
  push:
    branches: ['main']
  pull_request:
    branches: ['main']

permissions:
  contents: read

jobs:
  # Build
  build:
    name: Build (Nest + Prisma)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js 22
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npx prisma generate

      - name: Build project
        run: npm run build

  # Docker build/push, EC2 deploy, Health check
  docker-and-deploy:
    name: Docker build/push -> Deploy to EC2 -> Health check
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Docker Hub 로그인
      - name: Log in to Docker Hub
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      # Docker 이미지 빌드
      - name: Build Docker image
        env:
          IMAGE: ${{ secrets.DOCKER_USERNAME }}/${{ secrets.IMAGE_NAME }}
        run: |
          if [ -z "${IMAGE}" ]; then
            echo "ERROR: IMAGE is empty. Check DOCKER_USERNAME / IMAGE_NAME secrets."
            exit 1
          fi
          docker build --no-cache -t "$IMAGE:latest" -t "$IMAGE:${{ github.sha }}" .

      # Docker 이미지 푸시
      - name: Push Docker image
        env:
          IMAGE: ${{ secrets.DOCKER_USERNAME }}/${{ secrets.IMAGE_NAME }}
        run: |
          docker push "$IMAGE:latest"
          docker push "$IMAGE:${{ github.sha }}"

      # .env 파일 EC2에 업로드
      - name: Upload .env to EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.PRIVATE_KEY }}
          script: |
            mkdir -p ~/apps/NB02_CODI-IT_BE
            cat > ~/apps/NB02_CODI-IT_BE/.env << 'EOF'
            ${{ secrets.ENV_PROD }}
            EOF

      # EC2에서 Docker Hub 로그인
      - name: Login Docker Hub on EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.PRIVATE_KEY }}
          script: |
            echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      # Prisma migrate 실행
      - name: Run Prisma Migrate on EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.PRIVATE_KEY }}
          script: |
            set -e
            IMAGE="${{ secrets.DOCKER_USERNAME }}/${{ secrets.IMAGE_NAME }}"
            ENV_FILE=~/apps/NB02_CODI-IT_BE/.env

            # .env 유효성 검사
            if [ ! -f "$ENV_FILE" ]; then
              echo "ERROR: $ENV_FILE not found"
              exit 1
            fi
            if ! grep -qE '^DATABASE_URL=' "$ENV_FILE"; then
              echo "ERROR: DATABASE_URL missing in $ENV_FILE"
              exit 1
            fi
            if ! grep -qE '^DATABASE_URL=(postgresql|postgres)://' "$ENV_FILE"; then
              echo "ERROR: DATABASE_URL must start with postgresql:// or postgres://"
              exit 1
            fi

            echo "Running Prisma Migrate..."
            docker pull "$IMAGE:latest"
            docker run --rm --env-file "$ENV_FILE" "$IMAGE:latest" npx prisma migrate deploy

      # Blue, Green
      - name: Deploy Blue, Green on EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.PRIVATE_KEY }}
          script: |
            set -euo pipefail
            set -x  # 디버그 출력 (필요 없으면 제거)

            IMAGE="${{ secrets.DOCKER_USERNAME }}/${{ secrets.IMAGE_NAME }}"
            APP_DIR="$HOME/apps/NB02_CODI-IT_BE"
            ENV_FILE="$APP_DIR/.env"

            CONTAINER_BASENAME="${{ secrets.CONTAINER_NAME }}"
            [ -z "${CONTAINER_BASENAME:-}" ] && CONTAINER_BASENAME="codiit-backend"

            BLUE_PORT=3001
            GREEN_PORT=3002

            ACTIVE_LINK="/etc/nginx/conf.d/upstreams/active.conf"
            BLUE_CONF="/etc/nginx/conf.d/upstreams/blue.conf"
            GREEN_CONF="/etc/nginx/conf.d/upstreams/green.conf"

            echo "Check .env"
            test -f "$ENV_FILE" || (echo "ERROR: $ENV_FILE not found"; exit 1)
            grep -qE '^DATABASE_URL=' "$ENV_FILE" || (echo "ERROR: DATABASE_URL missing"; exit 1)

            if ! command -v curl >/dev/null 2>&1; then
              sudo yum install -y curl || true
            fi

            echo "Docker login & pull"
            echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
            docker pull "$IMAGE:latest"

            ACTIVE_COLOR="blue"
            if [ -L "$ACTIVE_LINK" ]; then
              TARGET=$(readlink "$ACTIVE_LINK" || true)
              case "$TARGET" in
                *green.conf) ACTIVE_COLOR="green" ;;
                *blue.conf)  ACTIVE_COLOR="blue" ;;
              esac
            fi

            if [ "$ACTIVE_COLOR" = "blue" ]; then
              IDLE_COLOR="green"; IDLE_PORT=$GREEN_PORT
              ACTIVE_PORT=$BLUE_PORT
            else
              IDLE_COLOR="blue"; IDLE_PORT=$BLUE_PORT
              ACTIVE_PORT=$GREEN_PORT
            fi

            ACTIVE_NAME="${CONTAINER_BASENAME}-${ACTIVE_COLOR}"
            IDLE_NAME="${CONTAINER_BASENAME}-${IDLE_COLOR}"

            echo "Active=$ACTIVE_COLOR($ACTIVE_PORT), Idle=$IDLE_COLOR($IDLE_PORT)"

            echo "Run idle container"
            docker stop "$IDLE_NAME" || true
            docker rm   "$IDLE_NAME" || true

            docker run -d \
              --name "$IDLE_NAME" \
              --restart unless-stopped \
              --env-file "$ENV_FILE" \
              -p 127.0.0.1:${IDLE_PORT}:3000 \
              "$IMAGE:latest"

            echo "Show just-started logs (10s tail)"
            sleep 2
            docker logs --tail=200 "$IDLE_NAME" || true

            # 헬스체크 경로: secret 없으면 /health 기본값
            HEALTH_PATH="${{ secrets.HEALTHCHECK_PATH }}"
            [ -z "${HEALTH_PATH:-}" ] && HEALTH_PATH="/health"

            echo "Health check idle: http://127.0.0.1:${IDLE_PORT}${HEALTH_PATH}"

            # 상태코드/본문 일부를 같이 찍어서 디버깅
            ok=0
            for i in $(seq 1 40); do
              code=$(curl -s -o /tmp/hbody -w "%{http_code}" "http://127.0.0.1:${IDLE_PORT}${HEALTH_PATH}" || echo "000")
              if [ "$code" = "200" ]; then
                ok=1
                break
              fi
              echo "[$i] waiting health... code=$code"
              if [ "$i" -eq 1 ] || [ "$i" -eq 10 ] || [ "$i" -eq 20 ] || [ "$i" -eq 30 ]; then
                echo "--- partial logs ---"
                docker logs --tail=200 "$IDLE_NAME" || true
              fi
              sleep 1
            done

            if [ "$ok" -ne 1 ]; then
              echo "ERROR: Health check failed"
              echo "Last HTTP code: $code"
              echo "--- last 200 logs ---"
              docker logs --tail=200 "$IDLE_NAME" || true
              echo "--- docker ps ---"
              docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
              exit 1
            fi

            echo "Switch Nginx to $IDLE_COLOR"
            if [ "$IDLE_COLOR" = "blue" ]; then
              sudo ln -sf "$BLUE_CONF" "$ACTIVE_LINK"
            else
              sudo ln -sf "$GREEN_CONF" "$ACTIVE_LINK"
            fi

            sudo nginx -t
            sudo nginx -s reload

            echo "Stop old active"
            docker stop "$ACTIVE_NAME" || true
            docker rm   "$ACTIVE_NAME" || true

            echo "Prune images"
            docker image prune -f || true
