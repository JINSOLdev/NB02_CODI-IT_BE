name: codiit-backend-ci-cd

on:
  push:
    branches: ['main']
  pull_request:
    branches: ['main']

permissions:
  contents: read

jobs:
  # 1) Build (Nest + Prisma)
  build:
    name: Build (Nest + Prisma)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js 22
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npx prisma generate

      - name: Build project
        run: npm run build

  # 2) Docker build/push -> Prisma migrate -> Blue/Green deploy
  docker-and-deploy:
    name: Docker build/push -> Deploy to EC2 -> Health check
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Docker Hub 로그인
      - name: Log in to Docker Hub
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      # Docker 이미지 빌드
      - name: Build Docker image
        env:
          IMAGE: ${{ secrets.DOCKER_USERNAME }}/${{ secrets.IMAGE_NAME }}
        run: |
          if [ -z "${IMAGE}" ]; then
            echo "ERROR: IMAGE is empty. Check DOCKER_USERNAME / IMAGE_NAME secrets."
            exit 1
          fi
          docker build --no-cache -t "$IMAGE:latest" -t "$IMAGE:${{ github.sha }}" .

      # Docker 이미지 푸시
      - name: Push Docker image
        env:
          IMAGE: ${{ secrets.DOCKER_USERNAME }}/${{ secrets.IMAGE_NAME }}
        run: |
          docker push "$IMAGE:latest"
          docker push "$IMAGE:${{ github.sha }}"

      # SSH 파일 복원
      - name: Restore SSH key file
        run: |
          echo "${{ secrets.PRIVATE_KEY_B64 }}" | base64 -d > /tmp/deploy_key.pem
          chmod 600 /tmp/deploy_key.pem

      # SSH로 직접 접속 테스트
      - name: SSH test
        run: |
          ssh -i /tmp/deploy_key.pem -o StrictHostKeyChecking=no ${{ secrets.SSH_USER }}@${{ secrets.HOST }} "echo connected && whoami && hostname"

      # .env 업로드는 scp로
      - name: Upload .env via scp
        run: |
          echo "${{ secrets.ENV_PROD }}" > /tmp/.env
          scp -i /tmp/deploy_key.pem -o StrictHostKeyChecking=no /tmp/.env ${{ secrets.SSH_USER }}@${{ secrets.HOST }}:~/apps/NB02_CODI-IT_BE/.env

      # .env 파일 EC2에 업로드
      # - name: Upload .env to EC2
      #   uses: appleboy/ssh-action@v1.0.3
      #   with:
      # host: ${{ secrets.HOST }}
      # username: ${{ secrets.SSH_USER }}
      # port: 22
      # key: ${{ secrets.PRIVATE_KEY_B64 }}
      # key_path: /tmp/deploy_key.pem
      # timeout: 120s
      # command_timeout: 10m
      # debug: true
      # script_stop: true
      # script: |
      #   set -euxo pipefail
      #   echo "connected"
      #   whoami
      #   hostname
      # mkdir -p ~/apps/NB02_CODI-IT_BE
      # cat > ~/apps/NB02_CODI-IT_BE/.env << 'EOF'
      # ${{ secrets.ENV_PROD }}
      # EOF

      # EC2에서 Docker Hub 로그인
      - name: Login Docker Hub on EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.PRIVATE_KEY }}
          script: |
            echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      # 자동 청소 스크립트
      - name: Cleanup Docker on EC2 (before pull)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.PRIVATE_KEY }}
          script: |
            set -e
            df -h
            docker system df || true
            docker system prune -af --volumes || true
            docker builder prune -af || true
            df -h

      # Prisma migrate 실행
      - name: Run Prisma Migrate on EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.PRIVATE_KEY }}
          script: |
            set -e
            IMAGE="${{ secrets.DOCKER_USERNAME }}/${{ secrets.IMAGE_NAME }}"
            ENV_FILE=~/apps/NB02_CODI-IT_BE/.env

            # .env 유효성 검사
            if [ ! -f "$ENV_FILE" ]; then
              echo "ERROR: $ENV_FILE not found"
              exit 1
            fi
            if ! grep -qE '^DATABASE_URL=' "$ENV_FILE"; then
              echo "ERROR: DATABASE_URL missing in $ENV_FILE"
              exit 1
            fi
            if ! grep -qE '^DATABASE_URL=(postgresql|postgres)://' "$ENV_FILE"; then
              echo "ERROR: DATABASE_URL must start with postgresql:// or postgres://"
              exit 1
            fi

            echo "Running Prisma Migrate..."
            docker pull "$IMAGE:latest"
            docker run --rm --env-file "$ENV_FILE" "$IMAGE:latest" npx prisma migrate deploy

      # Blue/Green 배포 + 헬스체크
      - name: Deploy Blue, Green on EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.PRIVATE_KEY }}
          script: |
            set -euo pipefail
            set -x  # 디버그 출력

            IMAGE="${{ secrets.DOCKER_USERNAME }}/${{ secrets.IMAGE_NAME }}"
            APP_DIR="$HOME/apps/NB02_CODI-IT_BE"
            ENV_FILE="$APP_DIR/.env"

            CONTAINER_BASENAME="${{ secrets.CONTAINER_NAME }}"
            [ -z "${CONTAINER_BASENAME:-}" ] && CONTAINER_BASENAME="codiit-backend"

            BLUE_PORT=3001
            GREEN_PORT=3002

            DOMAIN="https://codi-it.shop"
            HEALTH_PATH="${{ secrets.HEALTHCHECK_PATH }}"

            # ✅ HEALTH_PATH 안전 정규화 (공백 제거 + 슬래시 보정 + 기본값)
            HEALTH_PATH="${HEALTH_PATH//[[:space:]]/}"
            [ -z "${HEALTH_PATH:-}" ] && HEALTH_PATH="/api/health"
            [[ "$HEALTH_PATH" != /* ]] && HEALTH_PATH="/$HEALTH_PATH"
            echo "Using HEALTH_PATH=$HEALTH_PATH"

            ACTIVE_LINK="/etc/nginx/conf.d/upstreams/active.conf"
            BLUE_CONF="/etc/nginx/conf.d/upstreams/blue.conf"
            GREEN_CONF="/etc/nginx/conf.d/upstreams/green.conf"

            echo "Check .env"
            test -f "$ENV_FILE" || (echo "ERROR: $ENV_FILE not found"; exit 1)
            grep -qE '^DATABASE_URL=' "$ENV_FILE" || (echo "ERROR: DATABASE_URL missing"; exit 1)

            if ! command -v curl >/dev/null 2>&1; then
              sudo yum install -y curl || true
            fi

            echo "Docker login & pull"
            echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
            docker pull "$IMAGE:latest"

            # ✅ upstream 파일/폴더가 없으면 nginx 스위칭에서 터지니 사전 보장
            sudo mkdir -p /etc/nginx/conf.d/upstreams
            sudo test -f "$BLUE_CONF"  || echo 'include /etc/nginx/conf.d/upstreams/blue.upstream;'  | sudo tee "$BLUE_CONF"  >/dev/null
            sudo test -f "$GREEN_CONF" || echo 'include /etc/nginx/conf.d/upstreams/green.upstream;' | sudo tee "$GREEN_CONF" >/dev/null
            sudo test -L "$ACTIVE_LINK" || sudo ln -sf "$BLUE_CONF" "$ACTIVE_LINK" || true

            # 현재 활성 판단
            ACTIVE_COLOR="blue"
            if [ -L "$ACTIVE_LINK" ]; then
              TARGET=$(readlink "$ACTIVE_LINK" || true)
              case "$TARGET" in
                *green.conf) ACTIVE_COLOR="green" ;;
                *blue.conf)  ACTIVE_COLOR="blue" ;;
              esac
            fi

            if [ "$ACTIVE_COLOR" = "blue" ]; then
              IDLE_COLOR="green"; IDLE_PORT=$GREEN_PORT
              ACTIVE_PORT=$BLUE_PORT
            else
              IDLE_COLOR="blue"; IDLE_PORT=$BLUE_PORT
              ACTIVE_PORT=$GREEN_PORT
            fi

            ACTIVE_NAME="${CONTAINER_BASENAME}-${ACTIVE_COLOR}"
            IDLE_NAME="${CONTAINER_BASENAME}-${IDLE_COLOR}"

            echo "Active=$ACTIVE_COLOR($ACTIVE_PORT), Idle=$IDLE_COLOR($IDLE_PORT)"

            # 새(비활성) 컨테이너 실행
            echo "Run idle container: $IDLE_NAME"
            docker stop "$IDLE_NAME" || true
            docker rm   "$IDLE_NAME" || true

            docker run -d \
              --name "$IDLE_NAME" \
              --restart unless-stopped \
              --env-file "$ENV_FILE" \
              -p 127.0.0.1:${IDLE_PORT}:3000 \
              "$IMAGE:latest"

            # ✅ 컨테이너가 바로 죽는지 먼저 확인
            echo "--- docker ps (idle) ---"
            docker ps -a --filter "name=$IDLE_NAME" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

            echo "Show just-started logs (tail 200)"
            sleep 2
            docker logs --tail=200 "$IDLE_NAME" || true

            # ✅ 호스트에서 포트가 실제로 열렸는지(리스닝) 확인
            echo "--- host listen check ---"
            if command -v ss >/dev/null 2>&1; then
              ss -lntp | grep ":${IDLE_PORT} " || true
            else
              sudo yum install -y net-tools || true
              netstat -lntp | grep ":${IDLE_PORT} " || true
            fi

            echo "Health check idle: http://127.0.0.1:${IDLE_PORT}${HEALTH_PATH}"

            ok=0
            last_code="000"

            for i in $(seq 1 40); do
              # ✅ http_code 계산 버그 수정 (실패 시 정확히 000)
              code=$(curl -sS -o /tmp/hbody -w "%{http_code}" "http://127.0.0.1:${IDLE_PORT}${HEALTH_PATH}" || printf "000")
              last_code="$code"

              if [ "$code" = "200" ]; then
                ok=1
                break
              fi

              echo "[$i] waiting health... code=$code"

              # ✅ 처음/중간에 상태 + exitcode + 로그를 같이 확인
              if [ "$i" -eq 1 ] || [ "$i" -eq 10 ] || [ "$i" -eq 20 ] || [ "$i" -eq 30 ]; then
                echo "--- inspect (idle) ---"
                docker inspect "$IDLE_NAME" --format 'State={{.State.Status}} Exit={{.State.ExitCode}} Error={{.State.Error}}' || true

                echo "--- partial logs ---"
                docker logs --tail=200 "$IDLE_NAME" || true

                echo "--- curl verbose once (no secret) ---"
                curl -v "http://127.0.0.1:${IDLE_PORT}${HEALTH_PATH}" || true
              fi

              sleep 1
            done

            if [ "$ok" -ne 1 ]; then
              echo "ERROR: Health check failed"
              echo "Last HTTP code: $last_code"
              echo "--- last 200 logs ---"
              docker logs --tail=200 "$IDLE_NAME" || true
              echo "--- docker ps ---"
              docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
              echo "--- inspect (idle) ---"
              docker inspect "$IDLE_NAME" --format 'State={{.State.Status}} Exit={{.State.ExitCode}} Error={{.State.Error}}' || true
              echo "--- last response body (first 200 chars) ---"
              head -c 200 /tmp/hbody || true
              exit 1
            fi

            echo "Switch Nginx to $IDLE_COLOR"
            if [ "$IDLE_COLOR" = "blue" ]; then
              sudo ln -sf "$BLUE_CONF" "$ACTIVE_LINK"
            else
              sudo ln -sf "$GREEN_CONF" "$ACTIVE_LINK"
            fi

            sudo nginx -t
            sudo nginx -s reload

            # 도메인(443) 경유 헬스체크
            for i in $(seq 1 20); do
              if curl -fsS "${DOMAIN}${HEALTH_PATH}" >/dev/null 2>&1; then
                echo "Domain health OK: ${DOMAIN}${HEALTH_PATH}"
                break
              fi
              echo "Waiting domain health... ($i/20)"
              sleep 1
              if [ $i -eq 20 ]; then
                echo "ERROR: Domain health check failed"
                exit 1
              fi
            done

            # Swagger 체크
            if curl -fsSIL "${DOMAIN}/api/docs" >/dev/null 2>&1; then
              echo "Swagger reachable"
            else
              echo "WARNING: Swagger not reachable (check prod swagger setting or nginx routes)"
            fi

            # 이전 활성 컨테이너 정리
            echo "Stop old active: $ACTIVE_NAME"
            docker stop "$ACTIVE_NAME" || true
            docker rm   "$ACTIVE_NAME" || true

            echo "Prune images"
            docker image prune -f || true
