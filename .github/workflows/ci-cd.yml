name: codiit-backend-ci-cd

on:
  push:
    branches: ['main']
  pull_request:
    branches: ['main']

permissions:
  contents: read

jobs:
  # 1) Build (Nest + Prisma)
  build:
    name: Build (Nest + Prisma)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js 22
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npx prisma generate

      - name: Build project
        run: npm run build

  # 2) Docker build/push -> Prisma migrate -> Blue/Green deploy
  docker-and-deploy:
    name: Docker build/push -> Deploy to EC2 -> Health check
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Docker Hub 로그인
      - name: Log in to Docker Hub
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      # Docker 이미지 빌드
      - name: Build Docker image
        env:
          IMAGE: ${{ secrets.DOCKER_USERNAME }}/${{ secrets.IMAGE_NAME }}
        run: |
          if [ -z "${IMAGE}" ]; then
            echo "ERROR: IMAGE is empty. Check DOCKER_USERNAME / IMAGE_NAME secrets."
            exit 1
          fi
          docker build --no-cache -t "$IMAGE:latest" -t "$IMAGE:${{ github.sha }}" .

      # Docker 이미지 푸시
      - name: Push Docker image
        env:
          IMAGE: ${{ secrets.DOCKER_USERNAME }}/${{ secrets.IMAGE_NAME }}
        run: |
          docker push "$IMAGE:latest"
          docker push "$IMAGE:${{ github.sha }}"

      # HOST 디버그 출력
      - name: Debug HOST resolution
        run: |
          echo "HOST is set (length only): ${#HOST}"
        env:
          HOST: ${{ secrets.HOST }}

      # HOST 해석 시도
      - name: Resolve HOST
        run: |
          echo "HOST length: ${#HOST}"
          getent hosts "$HOST" || true
          nslookup "$HOST" || true
        env:
          HOST: ${{ secrets.HOST }}

      # TCP 22 포트 체크
      - name: Check TCP 22 from runner
        run: |
          sudo apt-get update -y
          sudo apt-get install -y netcat-openbsd
          nc -vz "$HOST" 22 -w 5
        env:
          HOST: ${{ secrets.HOST }}

      # .env 파일 EC2에 업로드
      - name: Upload .env to EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.PRIVATE_KEY }}
          timeout: 120s
          command_timeout: 10m
          debug: true
          script_stop: true
          script: |
            set -eux
            echo "connected"
            whoami
            hostname
            # mkdir -p ~/apps/NB02_CODI-IT_BE
            # cat > ~/apps/NB02_CODI-IT_BE/.env << 'EOF'
            # ${{ secrets.ENV_PROD }}
            # EOF

      # EC2에서 Docker Hub 로그인
      - name: Login Docker Hub on EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.PRIVATE_KEY }}
          script: |
            echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      # Prisma migrate 실행
      - name: Run Prisma Migrate on EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.PRIVATE_KEY }}
          script: |
            set -e
            IMAGE="${{ secrets.DOCKER_USERNAME }}/${{ secrets.IMAGE_NAME }}"
            ENV_FILE=~/apps/NB02_CODI-IT_BE/.env

            # .env 유효성 검사
            if [ ! -f "$ENV_FILE" ]; then
              echo "ERROR: $ENV_FILE not found"
              exit 1
            fi
            if ! grep -qE '^DATABASE_URL=' "$ENV_FILE"; then
              echo "ERROR: DATABASE_URL missing in $ENV_FILE"
              exit 1
            fi
            if ! grep -qE '^DATABASE_URL=(postgresql|postgres)://' "$ENV_FILE"; then
              echo "ERROR: DATABASE_URL must start with postgresql:// or postgres://"
              exit 1
            fi

            echo "Running Prisma Migrate..."
            docker pull "$IMAGE:latest"
            docker run --rm --env-file "$ENV_FILE" "$IMAGE:latest" npx prisma migrate deploy

      # Blue/Green 배포 + 헬스체크
      - name: Deploy Blue, Green on EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.PRIVATE_KEY }}
          script: |
            set -euo pipefail
            set -x  # 디버그 출력 (필요 없으면 제거)

            IMAGE="${{ secrets.DOCKER_USERNAME }}/${{ secrets.IMAGE_NAME }}"
            APP_DIR="$HOME/apps/NB02_CODI-IT_BE"
            ENV_FILE="$APP_DIR/.env"

            CONTAINER_BASENAME="${{ secrets.CONTAINER_NAME }}"
            [ -z "$CONTAINER_BASENAME" ] && CONTAINER_BASENAME="codiit-backend"

            BLUE_PORT=3001
            GREEN_PORT=3002

            DOMAIN="https://codi-it.shop"
            HEALTH_PATH="${{ secrets.HEALTHCHECK_PATH }}"
            [ -z "${HEALTH_PATH:-}" ] && HEALTH_PATH="/api/health"

            ACTIVE_LINK="/etc/nginx/conf.d/upstreams/active.conf"
            BLUE_CONF="/etc/nginx/conf.d/upstreams/blue.conf"
            GREEN_CONF="/etc/nginx/conf.d/upstreams/green.conf"

            echo "Check .env"
            test -f "$ENV_FILE" || (echo "ERROR: $ENV_FILE not found"; exit 1)
            grep -qE '^DATABASE_URL=' "$ENV_FILE" || (echo "ERROR: DATABASE_URL missing"; exit 1)

            if ! command -v curl >/dev/null 2>&1; then
              sudo yum install -y curl || true
            fi

            echo "Docker login & pull"
            echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
            docker pull "$IMAGE:latest"

            # 포트 헬스체크 함수
            wait_health () {
              local PORT="$1"
              local RETRIES="${2:-30}"
              local SLEEP_SECS="${3:-1}"
              for i in $(seq 1 "$RETRIES"); do
                if curl -fsS "http://127.0.0.1:${PORT}${HEALTH_PATH}" >/dev/null 2>&1; then
                  echo "Health OK on ${PORT}"
                  return 0
                fi
                echo "Waiting health on ${PORT}... ($i/$RETRIES)"
                sleep "$SLEEP_SECS"
              done
              echo "ERROR: Health check failed on ${PORT}"
              return 1
            }

            # 현재 활성 판단
            ACTIVE_COLOR="blue"
            if [ -L "$ACTIVE_LINK" ]; then
              TARGET=$(readlink "$ACTIVE_LINK" || true)
              case "$TARGET" in
                *green.conf) ACTIVE_COLOR="green" ;;
                *blue.conf)  ACTIVE_COLOR="blue" ;;
              esac
            fi

            if [ "$ACTIVE_COLOR" = "blue" ]; then
              IDLE_COLOR="green"; IDLE_PORT=$GREEN_PORT 
              ACTIVE_PORT=$BLUE_PORT
            else
              IDLE_COLOR="blue"; IDLE_PORT=$BLUE_PORT
              ACTIVE_PORT=$GREEN_PORT
            fi

            ACTIVE_NAME="${CONTAINER_BASENAME}-${ACTIVE_COLOR}"
            IDLE_NAME="${CONTAINER_BASENAME}-${IDLE_COLOR}"

            echo "Active=$ACTIVE_COLOR($ACTIVE_PORT), Idle=$IDLE_COLOR($IDLE_PORT)"

            # 새(비활성) 컨테이너 실행
            echo "Run idle container: $IDLE_NAME"
            docker stop "$IDLE_NAME" || true
            docker rm   "$IDLE_NAME" || true

            docker run -d \
              --name "$IDLE_NAME" \
              --restart unless-stopped \
              --env-file "$ENV_FILE" \
              -p 127.0.0.1:${IDLE_PORT}:3000 \
              "$IMAGE:latest"

            echo "Show just-started logs (10s tail)"
            sleep 2
            docker logs --tail=200 "$IDLE_NAME" || true

            echo "Health check idle: http://127.0.0.1:${IDLE_PORT}${HEALTH_PATH}"

            # 상태코드/본문 일부를 같이 찍어서 디버깅
            ok=0
            for i in $(seq 1 40); do
              code=$(curl -s -o /tmp/hbody -w "%{http_code}" "http://127.0.0.1:${IDLE_PORT}${HEALTH_PATH}" || echo "000")
              if [ "$code" = "200" ]; then
                ok=1
                break
              fi
              echo "[$i] waiting health... code=$code"
              if [ "$i" -eq 1 ] || [ "$i" -eq 10 ] || [ "$i" -eq 20 ] || [ "$i" -eq 30 ]; then
                echo "--- partial logs ---"
                docker logs --tail=200 "$IDLE_NAME" || true
              fi
              sleep 1
            done

            if [ "$ok" -ne 1 ]; then
              echo "ERROR: Health check failed"
              echo "Last HTTP code: $code"
              echo "--- last 200 logs ---"
              docker logs --tail=200 "$IDLE_NAME" || true
              echo "--- docker ps ---"
              docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
              exit 1
            fi

            echo "Switch Nginx to $IDLE_COLOR"
            if [ "$IDLE_COLOR" = "blue" ]; then
              sudo ln -sf "$BLUE_CONF" "$ACTIVE_LINK"
            else
              sudo ln -sf "$GREEN_CONF" "$ACTIVE_LINK"
            fi
            sudo nginx -t
            sudo nginx -s reload

            # 4) 전환 후, 도메인(443) 경유 헬스체크 (프록시/SSL 포함)
            for i in $(seq 1 20); do
              if curl -fsS "${DOMAIN}${HEALTH_PATH}" >/dev/null 2>&1; then
                echo "Domain health OK: ${DOMAIN}${HEALTH_PATH}"
                break
              fi
              echo "Waiting domain health... ($i/20)"
              sleep 1
              if [ $i -eq 20 ]; then
                echo "ERROR: Domain health check failed"
                exit 1
              fi
            done

            # 5) Swagger 접근성도 확인
            if curl -fsSIL "${DOMAIN}/api/docs" >/dev/null 2>&1; then
              echo "Swagger reachable"
            else
              echo "WARNING: Swagger not reachable (check prod swagger setting or nginx routes)"
            fi

            # 6) 이전 활성 컨테이너 정리
            echo "Stop old active: $ACTIVE_NAME"
            docker stop "$ACTIVE_NAME" || true
            docker rm   "$ACTIVE_NAME" || true

            # 7) 이미지 정리
            echo "Prune images"
            docker image prune -f || true
